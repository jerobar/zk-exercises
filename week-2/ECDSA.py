from random import randint, getrandbits
import hashlib


class EllipticCurve:
    def __init__(self, a, b, p, G, n):
        # Varibles a, b of the curve equation y^2 = x^3 + ax + b
        self.a = a
        self.b = b
        # Prime of the finite field
        self.p = p
        # Generator point
        self.G = G
        # Order of the group generated by G
        self.n = n

    def add_points(self, P, Q):
        """Adds points `P` and `Q` and returns the result."""
        # If `P` or `Q` are a point at infinity
        if P is None or Q is None:
            return P or Q

        Px, Py = P
        Qx, Qy = Q

        # If `P` and `Q` are additive inverses
        if Px == Qx and Py != Qy:
            return None

        if P == Q:
            # Point doubling
            m = (3 * Px ** 2 + self.a) * pow(2 * Py, -1, self.p)
        else:
            # Point addition
            m = (Qy - Py) * pow(Qx - Px, -1, self.p)

        Rx = (m ** 2 - Px - Qx) % self.p
        Ry = (m * (Px - Rx) - Py) % self.p

        return (Rx, Ry)

    def scalar_multiply_point(self, k, P):
        """Uses binary expansion to perform scalar multiplication of point `P` by `k`."""
        if k % self.n == 0 or P is None:
            return None

        result = None
        current = P

        while k:
            if k & 1:
                result = self.add_points(result, current)
            current = self.add_points(current, current)
            k >>= 1

        return result


class ECDSA:
    def __init__(self, a, b, p, G, n):
        # Elliptic curve to use
        self.curve = EllipticCurve(a, b, p, G, n)
        # Psuedo-random 256-bit int private key
        self.private_key = getrandbits(256)
        # Public key is a point along the curve: private_key * G
        self.public_key = self.curve.scalar_multiply_point(
            self.private_key, self.curve.G)

    def sign(self, e, m):
        # `k` is a random number between 0 and the curve order
        k = randint(0, self.curve.n)
        k_inverse = pow(k, self.curve.n - 2, self.curve.n) # pow(k, -1, self.curve.n)
        # `R` is the point k * G
        R = self.curve.scalar_multiply_point(k, self.curve.G)
        # `r` is the x coordinate of R
        r = R[0]
        # `z` is the int hash of the utf-8 ecoded message
        z = int.from_bytes(hashlib.sha256(m.encode('utf-8')).digest(), 'big')
        # `s` signature (z + re) / k
        s = (z + r*e) * k_inverse % self.curve.n

        return r, s, z, self.public_key

    def verify(self, r, s, z, P):
        s_inverse = pow(s, self.curve.n - 2, self.curve.n)
        # `u` = z/s
        u = z * s_inverse % self.curve.n
        # `v` = r/s
        v = r * s_inverse % self.curve.n
        # `total` = uG + uP
        total = self.curve.add_points(self.curve.scalar_multiply_point(u, self.curve.G),
                                      self.curve.scalar_multiply_point(v, P))

        return (total[0] == r)


# Generate a private and public key, pick a message m
secp256k1_ECDSA = ECDSA(
    a=0,
    b=7,
    p=2**256 - 2**32 - 977,
    G=(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
       0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8),
    n=0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141)
private_key = secp256k1_ECDSA.private_key
m = "hello, world"

# Sign m with private_key
r, s, h, Pubkey = secp256k1_ECDSA.sign(private_key, m)

# Verify r, s, h, Pubkey is valid
assert secp256k1_ECDSA.verify(r, s, h, Pubkey) == True
